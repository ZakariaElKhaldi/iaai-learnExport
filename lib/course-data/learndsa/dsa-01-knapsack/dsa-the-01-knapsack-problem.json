{
  "id": "d450b113-8c76-472d-a1f7-3b8d62c27aba",
  "title": "DSA The 0/1 Knapsack Problem",
  "slug": "dsa-the-01-knapsack-problem",
  "metadata": {
    "description": "Learn about DSA The 0/1 Knapsack Problem with clear explanations and practical examples.",
    "keywords": [
      "knapsack",
      "value",
      "capacity",
      "item",
      "problem",
      "items",
      "cell",
      "values",
      "current",
      "microscope"
    ],
    "difficulty": "intermediate",
    "prerequisites": [
      "C Basics"
    ],
    "estimated_time": 14,
    "category": "LearnDSA",
    "subcategory": "DSA 0/1 Knapsack"
  },
  "content_sections": [
    {
      "type": "introduction",
      "title": "Introduction",
      "content": "DSA The 0/1 Knapsack Problem",
      "order": 1,
      "code": null,
      "language": null,
      "explanation": null
    },
    {
      "type": "concept",
      "title": "Details",
      "content": "The 0/1 Knapsack Problem\nThe 0/1 Knapsack Problem states that you have a backpack with a weight limit, and you are in a room full of treasures, each treasure with a value and a weight.\nTo solve the 0/1 Knapsack Problem you must figure out which treasures to pack to maximize the total value, and at the same time keeping below the backpack's weight limit.\nBravo! You found the items that gives the maximum value\ud83d\ude00\n1\n2\n3\nKnapsack\n$ {{ totalValue }}\n{{ totalWeight }}/{{limit}} kg\n{{ item.name }}\n$ {{ item.value }}\n{{ item.weight }} kg\nAre you able to solve the 0/1 Knapsack Problem above manually? Continue reading to see different implementations that solves the 0/1 Knapsack Problem.\nSolving the 0/1 Knapsack Problem helps businesses decide which projects to fund within a budget, maximizing profit without overspending. It is also used in logistics to optimize the loading of goods into trucks and planes, ensuring the most valuable, or highest prioritized, items are included without exceeding weight limits.\nThe 0/1 Knapsack Problem\nRules\n:\nEvery item has a weight and value.\nYour knapsack has a weight limit.\nChoose which items you want to bring with you in the knapsack.\nYou can either take an item or not, you cannot take half of an item for example.\nGoal\n:\nMaximize the total value of the items in the knapsack.\nThe Brute Force Approach\nUsing brute force means to just check all possibilities, looking for the best result. This is usually the most straight forward way of solving a problem, but it also requires the most calculations.\nTo solve the 0/1 Knapsack Problem using brute force means to:\nCalculate the value of every possible combination of items in the knapsack.\nDiscard the combinations that are heavier than the knapsack weight limit.\nChoose the combination of items with the highest total value.\nHow it works:\nConsider each item one at a time.\nIf there is capacity left for the current item, add it by adding its value and reducing the remaining capacity with its weight. Then call the function on itself for the \nAlso, try not adding the current item before calling the function on itself for the \nReturn the maximum value from the two scenarios above (adding the current item, or not adding it).\nThis brute force approach to the 0/1 Knapsack problem can be implemented like this:\nExample\nSolving the 0/1 Knapsack Problem using recursion and brute force:\ndef knapsack_brute_force(capacity, n):\n    print(f\"knapsack_brute_force({capacity},{n})\")\n    if n == 0 or capacity == 0:\n        return 0\n\nelif weights[n-1] > capacity:\n        return knapsack_brute_force(capacity, n-1)\n\nelse:\n        include_item = values[n-1] + knapsack_brute_force(capacity-weights[n-1], n-1)\n        exclude_item = knapsack_brute_force(capacity, n-1)\n        return max(include_item, exclude_item)\n\nvalues = [300, 200, 400, 500]\nweights = [2, 1, 5, 3]\ncapacity = 10\nn = len(values)\n\nprint(\"\\nMaximum value in Knapsack =\", knapsack_brute_force(capacity, n))\nRun Example \u00bb\nRunning the code above means that the\nknapsack_brute_force\nfunction is called many times recursively. You can see that from all the printouts.\nEvery time the function is called, it will either include the current item\nn-1\nor not.\nLine 2:\nThis print statement shows us each time the function is called.\nLine 3-4:\nIf we run out of items to check (\nn==0\n), or we run out of capacity (\ncapacity==0\n), we do not do any more recursive calls because no more items can be added to the knapsack at this point.\nLine 6-7:\nIf the current item  is heavier than the capacity (\nweights[n-1] > capacity\n), forget the current item and go to the \nLine 10-12:\nIf the current item can be added to the knapsack, see what gives you the highest value: adding the current item, or not adding the current item.\nRunning the code example creates a recursion tree that looks like this, each gray box represents a function call:\nTake crown?\nTake cup?\nTake globe?\nTake microscope?\nknapsack(10,4):\ninclude = 500 + ks(7,3)\nexclude = ks(10,3)\nknapsack(7,3):\ninclude = 400 + ks(2,2)\nexclude = ks(7,2)\nknapsack(10,3):\ninclude = 400 + ks(5,2)\nexclude = ks(10,2)\nknapsack(2,2):\ninclude = 200 + ks(1,1)\nexclude = ks(2,1)\n0\nknapsack(7,2):\ninclude = 200 + ks(6,1)\nexclude = ks(7,1)\nknapsack(5,2):\ninclude = 200 + ks(4,1)\nexclude = ks(5,1)\nknapsack(10,2):\ninclude = 200 + ks(9,1)\nexclude = ks(10,1)\nknapsack(2,1):\ninclude = 300 + ks(0,0)\n0\nexclude = ks(2,0)\n0\nknapsack(6,1):\ninclude = 300 + ks(4,0)\n0\nexclude = ks(6,0)\n0\nknapsack(7,1):\ninclude = 300 + ks(5,0)\n0\nexclude = ks(7,0)\n0\nknapsack(4,1):\ninclude = 300 + ks(2,0)\n0\nexclude = ks(4,0)\n0\nknapsack(5,1):\ninclude = 300 + ks(3,0)\n0\nexclude = ks(5,0)\n0\nknapsack(9,1):\ninclude = 300 + ks(7,0)\n0\nexclude = ks(9,0)\n0\nknapsack(10,1):\ninclude = 300 + ks(8,0)\n0\nexclude = ks(10,0)\n0\nNote:\nIn the recursion tree above, writing the real function name\nknapsack_brute_force(7,3)\nwould make the drawing too wide, so \"ks(7,3)\" or \"knapsack(7,3)\" is written instead.\nFrom the recursion tree above, it is possible to see that for example taking the crown, the cup, and the globe, means that there is no space left for the microscope (2 kg), and that gives us a total value of 200+400+500=1100.\nWe can also see that only taking the microscope gives us a total value of 300 (right bottom gray box).\nAs you can see in the recursion tree above, and by running the example code, the function is sometimes called with the same arguments, like\nknapsack_brute_force(2,0)\nis for example called two times. We avoid this by using\nmemoization\n.\nThe Memoization Approach (top-down)\nThe memoization technique stores the \nRead more about memoization\nhere\n.\nMemoization is a 'top-down' approach because it starts solving the problem by working its way down to smaller and smaller subproblems.\nIn the brute force example above, the same function calls happen only a few times, so the effect of using memoization is not so big. But in other examples with far more items to choose from, the memoization technique would be more helpful.\nHow it works:\nIn addition to the initial brute force code above, create an array\nmemo\nto store \nFor every function call with arguments for capacity\nc\nand item number\ni\n, store the result in\nmemo[c,i]\n.\nTo avoid doing the same calculation more than once, every time the function is called with arguments\nc\nand\ni\n, check first if the result is already stored in\nmemo[c,i]\n.\nAfter improving the brute force implementation with the use of memoization, the code now looks like this:\nExample\nImproved solution to the 0/1 Knapsack Problem using memoization:\ndef knapsack_memoization(capacity, n):\n    print(f\"knapsack_memoization({n}, {capacity})\")\n    if memo[n][capacity] is not None:\n        print(f\"Using memo for ({n}, {capacity})\")\n        return memo[n][capacity]\n\nif n == 0 or capacity == 0:\n        result = 0\n    elif weights[n-1] > capacity:\n        result = knapsack_memoization(capacity, n-1)\n    else:\n        include_item = values[n-1] + knapsack_memoization(capacity-weights[n-1], n-1)\n        exclude_item = knapsack_memoization(capacity, n-1)\n        result = max(include_item, exclude_item)\n\nmemo[n][capacity] = result\n    return result\n\nvalues = [300, 200, 400, 500]\nweights = [2, 1, 5, 3]\ncapacity = 10\nn = len(values)\n\nmemo = [[None]*(capacity + 1) for _ in range(n + 1)]\n\nprint(\"\\nMaximum value in Knapsack =\", knapsack_memoization(capacity, n))\nRun Example \u00bb\nThe highlighted lines in the code above show the memoization technique used to improve the \nLine 24:\nCreate an array\nmemo\nwhere \nLine 3-5:\nAt the start of the function, before doing any calculations or recursive calls, check if the result has already been found and stored in the\nmemo\narray.\nLine 16:\nStore the result for later.\nThe Tabulation Approach (bottom-up)\nAnother technique to solve the 0/1 Knapsack problem is to use something called\ntabulation\n. This approach is also called the iterative approach, and is a technique used in\nDynamic Programming\n.\nTabulation solves the problem in a bottom-up manner by filling up a table with the results from the most basic subproblems first. The \nHow it works:\nConsider one item at a time, and increase the knapsack capacity from 0 to the knapsack limit.\nIf the current item is not too heavy, check what gives the highest value: adding it, or not adding it. Store the maximum of these two values in the table.\nIn case the current item is too heavy to be added, just use the \nUse the animation below to see how the table is filled cell by cell using \nFind the maximum value in the knapsack.\nClick \"Run\" to fill the table.\nAfter the table is filled, click a cell value to see the calculation.\nWeights (kg)\nKnapsack capacities (kg)\nValues ($)\nOi!\n{{n-1}}\n{{weight}}\n{{value}}\n\u2193\n+\n=\nMaximum Value in Knapsack:\n$\n{{ maxValue }}\nSpeed:\nRun\nThe tabulation approach works by considering one item at a time, for increasing knapsack capacities. In this way the solution is built up by solving the most basic subproblems first.\nOn each row an item is considered to be added to knapsack, for increasing capacities.\nExample\nImproved solution to the 0/1 Knapsack Problem using tabulation:\ndef knapsack_tabulation():\n    n = len(values)\n    tab = [[0]*(capacity + 1) for y in range(n + 1)]\n\nfor i in range(1, n+1):\n        for w in range(1, capacity+1):\n            if weights[i-1] <= w:\n                include_item = values[i-1] + tab[i-1][w-weights[i-1]]\n                exclude_item = tab[i-1][w]\n                tab[i][w] = max(include_item, exclude_item)\n            else:\n                tab[i][w] = tab[i-1][w]\n\nfor row in tab:\n    \t  print(row)\n    return tab[n][capacity]\n\nvalues = [300, 200, 400, 500]\nweights = [2, 1, 5, 3]\ncapacity = 10\nprint(\"\\nMaximum value in Knapsack =\", knapsack_tabulation())\nRun Example \u00bb\nLine 7-10:\nIf the item weight is lower than the capacity it means it can be added. Check if adding it gives a higher total value than the result calculated in the \nmax\n) of these two values. In other words: Choose to take, or not to take, the current item.\nLine 8:\nThis line might be the hardest to understand. To find the value that corresponds to adding the current item, we must use the current item's value from the\nvalues\narray. But in addition, we must reduce the capacity with the current item's weight, to see if the remaining capacity can give us any additional value. This is similar to check if other items can be added in addition to the current item, and adding the value of those items.\nLine 12:\nIn case the current item is heavier than the capacity (too heavy), just fill in the value from the \nManual Run Through\nHere is a list of explanations to how a few of the table values are calculated. You can click the corresponding table cell in the animation above to get a better understanding as you read.\nMicroscope, capacity 1 kg:\nFor the first value calculated, it is checked whether the microscope can be put in the bag if the weight limit is 1 kg. The microscope weighs 2 kg, it is too heavy, and so the value 0 is just copied from the cell above which corresponds to having no items in the knapsack. Only considering the microscope for a bag with weight limit 1 kg, means we cannot bring any items and we must leave empty handed with a total value of $ 0.\nMicroscope, capacity 2 kg:\nFor the second value calculated, we are able to fit the microscope in the bag for a weight limit of 2 kg, so we can bring it, and the total value in the bag is $ 300 (the value of the microscope). And for higher knapsack capacities, only considering the microscope, means we can bring it, and so all other values in that row is $ 300.\nGlobe, capacity 1 kg:\nConsidering the globe at 1 kg and a knapsack capacity at 1 kg means that we can bring the globe, so the value is $ 200. The code finds the maximum between bringing the globe which gives us $ 200, and the \nGlobe, capacity 2 kg:\nAt capacity 2 kg, the code sees that the globe can fit, which gives us a value of $ 200, but then the microscope cannot fit. And adding the microscope for a capacity of 2 kg gives us a value of $ 300, which is higher, so taking the microscope (value from the cell above) is the choice to maximize knapsack value for this table cell.\nGlobe, capacity 3 kg:\nConsidering the globe with a capacity of 3 kg, means that we can take the globe, but with the remaining capacity of 2 kg we can also take the microscope. In this cell, taking both the globe and the microscope gives us a higher value 200+300=500 than taking just the microscope (as calculated on the \nWhich Items Gives Us The Highest Value?\nAfter filling out the table and finding the maximum value the knapsack can have, it is not obvious which items we need to pack with us to get that value.\nTo find the included items, we use the table we have created, and we start with the bottom right cell with the highest value, in our case the cell with value 1200 in it.\nSteps to find the included items:\nStart with bottom right cell (the cell with the highest value).\nIf the cell above has the same value, it means that this row's item is not included, and we go to the cell above.\nIf the cell above has a different value, it means that the current row's item is included, and we move to the row above, and we move to the left as many times as the weight of the included item.\nContinue to do steps 2 and 3 until a cell with value 0 is found.\nHere is a drawing of how the included items are found, using the step-by-step method:\nWeights (kg)\nKnapsack capacities (kg)\nValues ($)\nOi!\n{{n-1}}\n{{weight}}\n{{value}}\n\u2193\n+\n=\nThis is how the included items are found:\nThe bottom right value is 1200, and the cell above is 900. The values are different, which means the crown is included.\nThe \nThe cell we are in now has value 700, and the cell above has value 500. The values are different, which means the item on the current row is included: the cup.\nThe cup weighs 5 kg, so the \nThe cell above has the same value 300, which means the globe is not included, and the \nSince the cell above is different than the current cell with value 300, it means the microscope is included.\nThe \nWe arrive at the upper leftmost cell. Since the value is 0, it means we are finished.\nOur 0/1 Knapsack problem has maximum value when these items are included: the crown, the cup, and the microscope.\nThe same steps are added to the code below, to find the items that make up the solution to the 0/1 Knapsack problem.\nExample\nExtended solution to the 0/1 Knapsack Problem to find the included items:\ndef knapsack_tabulation():\n    n = len(values)\n    tab = [[0] * (capacity + 1) for _ in range(n + 1)]\n\nfor i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i-1] <= w:\n                include_item = values[i-1] + tab[i-1][w - weights[i-1]]\n                exclude_item = tab[i-1][w]\n                tab[i][w] = max(include_item, exclude_item)\n            else:\n                tab[i][w] = tab[i-1][w]\n\nfor row in tab:\n        print(row)\n\nitems_included = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if tab[i][w] != tab[i-1][w]:\n            items_included.append(i-1)\n            w -= weights[i-1]\n\nprint(\"\\nItems included:\", items_included)\n\nreturn tab[n][capacity]\n\nvalues = [300, 200, 400, 500]\nweights = [2, 1, 5, 3]\ncapacity = 10\nprint(\"\\nMaximum value in Knapsack =\", knapsack_tabulation())\nRun Example \u00bb\nTime Complexity\nThe three approaches to solving the 0/1 Knapsack Problem run differently, and with different time complexities.\nBrute Force Approach:\nThis is the slowest of the three approaches. The possibilities are checked recursively, with the time complexity \\(O(2^n)\\), where \\(n\\) is the number of potential items we can pack. This means the number of computations double for each extra item that needs to be considered.\nMemoization Approach:\nSaves computations by remembering \nTabulation Approach:\nHas the same time complexity as the memoization approach \\(O(n \\cdot C)\\), where \\(n\\) is the number of items, and \\(C\\) is the knapsack capacity, but memory usage and the way it runs is more predictable, which normally makes the tabulation approach the most favorable.\nNote:\nMemoization\nand\ntabulation\nare used in something called\ndynamic programming\n, which is a powerful technique used in computer science to solve problems. To use dynamic programming to solve a problem, the problem must consist of overlapping subproblems, and that is why it can be used to solve the 0/1 Knapsack Problem, as you can see above in the memoization and tabulation approaches.\n\n\u2605\n+1",
      "order": 2,
      "code": null,
      "language": null,
      "explanation": null
    }
  ],
  "practice_exercises": [
    {
      "title": "Practice Exercise",
      "description": "Create an example that applies the concepts from this tutorial.",
      "difficulty": "medium",
      "starter_code": "# Add your code here",
      "solution": "# Example solution would go here"
    }
  ],
  "related_topics": [
    {
      "id": "0e8bc2f0-b5b1-4b77-9814-851c6e5df00c",
      "title": "C Best Practices",
      "relationship": "related_topic"
    },
    {
      "id": "1062413a-3ae1-46d0-9be4-47111a893961",
      "title": "C Common Pitfalls and How to Avoid Them",
      "relationship": "suggested_reading"
    },
    {
      "id": "7fa7f568-caad-4211-8092-3a8d071b740c",
      "title": "C Fundamentals",
      "relationship": "prerequisite"
    }
  ],
  "quiz": [
    {
      "question": "What is and you?",
      "options": [
        "None of the above.",
        "None of the above.",
        "in a room full of treasures",
        "also used in logistics to optimize the loading of goods into trucks and planes"
      ],
      "correct_answer": 2,
      "explanation": "The correct definition of and you is 'in a room full of treasures'."
    },
    {
      "question": "What is It?",
      "options": [
        "None of the above.",
        "None of the above.",
        "also used in logistics to optimize the loading of goods into trucks and planes",
        "in a room full of treasures"
      ],
      "correct_answer": 2,
      "explanation": "The correct definition of It is 'also used in logistics to optimize the loading of goods into trucks and planes'."
    }
  ],
  "summary": "This tutorial covers DSA The 0/1 Knapsack Problem concepts and techniques. You'll learn how to use DSA The 0/1 Knapsack Problem effectively, including key principles, common patterns, and practical examples. By the end of this tutorial, you'll have a solid understanding of DSA The 0/1 Knapsack Problem and how to apply it in your projects."
}