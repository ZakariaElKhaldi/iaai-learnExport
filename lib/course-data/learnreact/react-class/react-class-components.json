{
  "id": "160d3954-cef3-41a6-83b0-0357f82c448f",
  "title": "React Class Components",
  "slug": "react-class-components",
  "metadata": {
    "description": "Learn about React Class Components with clear explanations and practical examples.",
    "keywords": [
      "component",
      "state",
      "render",
      "react",
      "example",
      "root",
      "props",
      "method",
      "color",
      "class"
    ],
    "difficulty": "intermediate",
    "prerequisites": [
      "C Basics"
    ],
    "estimated_time": 13,
    "category": "LearnReact",
    "subcategory": "React Class"
  },
  "content_sections": [
    {
      "type": "introduction",
      "title": "Introduction",
      "content": "React Class Components",
      "order": 1,
      "code": null,
      "language": null,
      "explanation": null
    },
    {
      "type": "concept",
      "title": "Details",
      "content": "Before React 16.8, Class components were the only way to track state and lifecycle on a React component.\nFunction components were considered \"state-less\".\nWith the addition of Hooks, Function components are now almost equivalent to Class components.\nThe differences are so minor that you will probably never need to use a Class component in React.\nEven though Function components are preferred, there are no current plans on removing Class components from React.\nThis section will give you an overview of how to use Class components in React.\nFeel free to skip this section, and use Function Components instead.\nReact Components\nComponents are independent and reusable bits of code.\nThey serve the same purpose as JavaScript functions,\nbut work in isolation and return HTML via a render() function.\nComponents come in two types, Class components and Function components, in \nthis chapter you will learn about Class components.\nCreate a Class Component\nWhen creating a React component, the component's name must start with an \nupper case letter.\nThe component has to include the\nextends React.Component\nstatement, this statement creates an inheritance to \nReact.Component, and gives your component access to React.Component's functions.\nThe component also requires a\nrender()\nmethod, \nthis method returns HTML.\nExample\nCreate a Class component called\nCar\nclass Car extends React.Component {\n  render() {\n    return <h2>Hi, I am a Car!</h2>;\n  }\n}\nNow your React application has a component called Car, which returns a\n<h2>\nelement.\nTo use this component in your application, use similar syntax as normal HTML:\n<Car />\nExample\nDisplay the\nCar\ncomponent in the \"root\" element:\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Car />);\nRun \nExample \u00bb\nComponent Constructor\nIf there is a\nconstructor()\nfunction in your component, this function will be called when the \ncomponent gets initiated.\nThe constructor function is where you initiate the component's properties.\nIn React, component properties should be kept in an object called\nstate\n.\nYou will learn more about\nstate\nlater in \nthis tutorial.\nThe constructor function is also where you honor the inheritance of the \nparent component by including the\nsuper()\nstatement, which executes the parent component's constructor function, and your component has access to all the functions of \nthe parent component (\nReact.Component\n).\nExample\nCreate a constructor function in the Car component, and add a color property:\nclass Car extends React.Component {\n  constructor() {\n    super();\n    this.state = {color: \"red\"};\n  }\n  render() {\n    return <h2>I am a Car!</h2>;\n  }\n}\nUse the color property in the render() function:\nExample\nclass Car extends React.Component {\n  constructor() {\n    super();\n    this.state = {color: \"red\"};\n  }\n  render() {\n    return <h2>I am a {this.state.color} Car!</h2>;\n  }\n}\nRun \nExample \u00bb\nProps\nAnother way of handling component properties is by using\nprops\n.\nProps are like function arguments, and you send them into the component as attributes.\nYou will learn more about\nprops\nin the \nExample\nUse an attribute to pass a color to the Car component, and use it in the \nrender() function:\nclass Car extends React.Component {\n  render() {\n    return <h2>I am a {this.props.color} Car!</h2>;\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Car color=\"red\"/>);\nRun \nExample \u00bb\nProps in the Constructor\nIf your component has a constructor function,\nthe props should always be passed to the constructor and also to the React.Component via the\nsuper()\nmethod.\nExample\nclass Car extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return <h2>I am a {this.props.model}!</h2>;\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Car model=\"Mustang\"/>);\nRun \nExample \u00bb\nComponents in Components\nWe can refer to components inside other components:\nExample\nUse the Car component inside the Garage component:\nclass Car extends React.Component {\n  render() {\n    return <h2>I am a Car!</h2>;\n  }\n}\n\nclass Garage extends React.Component {\n  render() {\n    return (\n      <div>\n      <h1>Who lives in my Garage?</h1>\n      <Car />\n      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Garage />);\nRun \nExample \u00bb\nComponents in Files\nReact is all about re-using code, and it can be smart to insert some of your \ncomponents in separate files.\nTo do that, create a new file with a\n.js\nfile extension and put the code inside it:\nNote that the file must start by importing React (as before), and it has to \nend with the statement\nexport default Car;\n.\nExample\nThis is the new file, we named it\nCar.js\n:\nimport React from 'react';\n\nclass Car extends React.Component {\n  render() {\n    return <h2>Hi, I am a Car!</h2>;\n  }\n}\n\nexport default Car;\nTo be able to use the\nCar\ncomponent, you have to import the file in your \napplication.\nExample\nNow we import the\nCar.js\nfile in the application, and we can use the\nCar\ncomponent as if it was created here.\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport Car from './Car.js';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Car />);\nRun \nExample \u00bb\nReact Class Component State\nReact Class components have a built-in\nstate\nobject.\nYou might have noticed that we used\nstate\nearlier in the component constructor section.\nThe\nstate\nobject is where you store property values that belongs to the component.\nWhen the\nstate\nobject changes, the component re-renders.\nCreating the state Object\nThe state object is initialized in the constructor:\nExample\nSpecify the\nstate\nobject in the constructor method:\nclass Car extends React.Component {\n  constructor(props) {\n    super(props);\n  this.state = {brand: \"Ford\"};\n  }\n  render() {\n    return (\n      <div>\n        <h1>My Car</h1>\n      </div>\n    );\n  }\n}\nThe state object can contain as many properties as you like:\nExample\nSpecify all the properties your component need:\nclass Car extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      brand: \"Ford\",\n      model: \"Mustang\",\n      color: \"red\",\n      year: 1964\n    };\n  }\n  render() {\n    return (\n      <div>\n        <h1>My Car</h1>\n      </div>\n    );\n  }\n}\nUsing the\nstate\nObject\nRefer to the\nstate\nobject anywhere in the component by using the\nthis.state.\npropertyname\nsyntax:\nExample:\nRefer to the\nstate\nobject in the\nrender()\nmethod:\nclass Car extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      brand: \"Ford\",\n      model: \"Mustang\",\n      color: \"red\",\n      year: 1964\n    };\n  }\n  render() {\n    return (\n      <div>\n        <h1>My {this.state.brand}</h1>\n        <p>\n          It is a {this.state.color}\n          {this.state.model}\n          from {this.state.year}.\n        </p>\n      </div>\n    );\n  }\n}\nRun \nExample \u00bb\nChanging the\nstate\nObject\nTo change a value in the state object, use the\nthis.setState()\nmethod.\nWhen a value in the\nstate\nobject changes, \nthe component will re-render, meaning that the output will change according to \nthe new value(s).\nExample:\nAdd a button with an\nonClick\nevent that \n  will change the color property:\nclass Car extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      brand: \"Ford\",\n      model: \"Mustang\",\n      color: \"red\",\n      year: 1964\n    };\n  }\n  changeColor = () => {\n    this.setState({color: \"blue\"});\n  }\n  render() {\n    return (\n      <div>\n        <h1>My {this.state.brand}</h1>\n        <p>\n          It is a {this.state.color}\n          {this.state.model}\n          from {this.state.year}.\n        </p>\n        <button\n          type=\"button\"\n          onClick={this.changeColor}\n        >Change color</button>\n      </div>\n    );\n  }\n}\nRun \nExample \u00bb\nAlways use the\nsetState()\nmethod to change the state object,\nit will ensure that the component knows its been updated and calls the render() method\n(and all the other lifecycle methods).\nLifecycle of Components\nEach component in React has a lifecycle which you can monitor and manipulate during its \nthree main phases.\nThe three phases are:\nMounting\n,\nUpdating\n, and\nUnmounting\n.\nMounting\nMounting means putting elements into the DOM.\nReact has four built-in methods that gets called, in this order, when \nmounting a component:\nconstructor()\ngetDerivedStateFromProps()\nrender()\ncomponentDidMount()\nThe\nrender()\nmethod is required and will \nalways be called, the others are optional and will be called if you define them.\nconstructor\nThe\nconstructor()\nmethod is called before anything else, \nwhen the component is initiated, and it is the natural \nplace to set up the initial\nstate\nand other \ninitial values.\nThe\nconstructor()\nmethod is called with the\nprops\n, as arguments, and you should always \nstart by calling the\nsuper(props)\nbefore \nanything else, this will initiate the parent's constructor method and allows the \ncomponent to inherit methods from its parent (\nReact.Component\n).\nExample:\nThe\nconstructor\nmethod is called, by \n  React, every time you make a component:\nclass Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  render() {\n    return (\n      <h1>My Favorite Color is {this.state.favoritecolor}</h1>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Header />);\nRun \nExample \u00bb\ngetDerivedStateFromProps\nThe\ngetDerivedStateFromProps()\nmethod is \ncalled right before rendering the element(s) in the DOM.\nThis is the natural place to set the\nstate\nobject based on the initial\nprops\n.\nIt takes\nstate\nas an argument, and returns an object with changes to the\nstate\n.\nThe example below starts with the favorite color being \n\"red\", but the\ngetDerivedStateFromProps()\nmethod updates the favorite color based on the\nfavcol\nattribute:\nExample:\nThe\ngetDerivedStateFromProps\nmethod is called \n  right before the render method:\nclass Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  static getDerivedStateFromProps(props, state) {\n    return {favoritecolor: props.favcol };\n  }\n  render() {\n    return (\n      <h1>My Favorite Color is {this.state.favoritecolor}</h1>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Header favcol=\"yellow\"/>);\nRun \nExample \u00bb\nrender\nThe\nrender()\nmethod is required, and is the \nmethod that actually outputs the HTML to the DOM.\nExample:\nA simple component with a simple\nrender()\nmethod:\nclass Header extends React.Component {\n  render() {\n    return (\n      <h1>This is the content of the Header component</h1>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Header />);\nRun \nExample \u00bb\ncomponentDidMount\nThe\ncomponentDidMount()\nmethod is called after the \ncomponent is rendered.\nThis is where you run statements that requires that the component is already placed in the DOM.\nExample:\nAt first my favorite color is red, but give me a second, and it is yellow \n  instead:\nclass Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  componentDidMount() {\n    setTimeout(() => {\n      this.setState({favoritecolor: \"yellow\"})\n    }, 1000)\n  }\n  render() {\n    return (\n      <h1>My Favorite Color is {this.state.favoritecolor}</h1>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Header />);\nRun \nExample \u00bb\nUpdating\nThe \nupdated\n.\nA component is updated whenever there is a change in the component's\nstate\nor\nprops\n.\nReact has five built-in methods that gets called, in this order, when a component \nis updated:\ngetDerivedStateFromProps()\nshouldComponentUpdate()\nrender()\ngetSnapshotBeforeUpdate()\ncomponentDidUpdate()\nThe\nrender()\nmethod is required and will \nalways be called, the others are optional and will be called if you define them.\ngetDerivedStateFromProps\nAlso at\nupdates\nthe\ngetDerivedStateFromProps\nmethod is \ncalled. This is the first method that is called when a component gets updated.\nThis is still the natural place to set the\nstate\nobject based on the initial props.\nThe example below has a button that changes the favorite color to blue, but \nsince the\ngetDerivedStateFromProps()\nmethod is called, \nwhich updates the state with the color from the favcol attribute, the favorite color is \nstill \nrendered as yellow:\nExample:\nIf the component gets updated, the\ngetDerivedStateFromProps()\nmethod is called:\nclass Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  static getDerivedStateFromProps(props, state) {\n    return {favoritecolor: props.favcol };\n  }\n  changeColor = () => {\n    this.setState({favoritecolor: \"blue\"});\n  }\n  render() {\n    return (\n      <div>\n      <h1>My Favorite Color is {this.state.favoritecolor}</h1>\n      <button type=\"button\" onClick={this.changeColor}>Change color</button>\n      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Header favcol=\"yellow\" />);\nRun \nExample \u00bb\nshouldComponentUpdate\nIn the\nshouldComponentUpdate()\nmethod\nyou can return a Boolean value that specifies whether React should continue with the rendering or not.\nThe default value is\ntrue\n.\nThe example below shows what happens when the\nshouldComponentUpdate()\nmethod returns\nfalse\n:\nExample:\nStop the component from rendering at any update:\nclass Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  shouldComponentUpdate() {\n    return false;\n  }\n  changeColor = () => {\n    this.setState({favoritecolor: \"blue\"});\n  }\n  render() {\n    return (\n      <div>\n      <h1>My Favorite Color is {this.state.favoritecolor}</h1>\n      <button type=\"button\" onClick={this.changeColor}>Change color</button>\n      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Header />);\nRun \nExample \u00bb\nExample:\nSame example as above, but this time the\nshouldComponentUpdate()\nmethod returns\ntrue\ninstead:\nclass Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  shouldComponentUpdate() {\n    return true;\n  }\n  changeColor = () => {\n    this.setState({favoritecolor: \"blue\"});\n  }\n  render() {\n    return (\n      <div>\n      <h1>My Favorite Color is {this.state.favoritecolor}</h1>\n      <button type=\"button\" onClick={this.changeColor}>Change color</button>\n      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Header />);\nRun \nExample \u00bb\nrender\nThe\nrender()\nmethod is of course called when a component gets\nupdated\n, \nit has to re-render the HTML to the DOM, with the new changes.\nThe example below has a button that changes the favorite color to blue:\nExample:\nClick the button to make a change in the component's state:\nclass Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  changeColor = () => {\n    this.setState({favoritecolor: \"blue\"});\n  }\n  render() {\n    return (\n      <div>\n      <h1>My Favorite Color is {this.state.favoritecolor}</h1>\n      <button type=\"button\" onClick={this.changeColor}>Change color</button>\n      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Header />);\nRun \nExample \u00bb\ngetSnapshotBeforeUpdate\nIn the\ngetSnapshotBeforeUpdate()\nmethod\nyou have access to the\nprops\nand\nstate\nbefore\nthe update, meaning that \neven after the update, you can check what the values were\nbefore\nthe \nupdate.\nIf the\ngetSnapshotBeforeUpdate()\nmethod\nis present, you should also include the\ncomponentDidUpdate()\nmethod, otherwise you will get an error.\nThe example below might seem complicated, but all it does is this:\nWhen the component is\nmounting\nit is rendered with the favorite \ncolor \"red\".\nWhen the component\nhas been mounted,\na timer changes the state, and \nafter one second, the favorite color becomes \"yellow\".\nThis action triggers the\nupdate\nphase, and since this component has a\ngetSnapshotBeforeUpdate()\nmethod, this method is executed, and writes a \nmessage to the empty DIV1 element.\nThen the\ncomponentDidUpdate()\nmethod is \nexecuted and writes a message in the empty DIV2 element:\nExample:\nUse the\ngetSnapshotBeforeUpdate()\nmethod to find out \n  what the\nstate\nobject looked like before \n  the update:\nclass Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  componentDidMount() {\n    setTimeout(() => {\n      this.setState({favoritecolor: \"yellow\"})\n    }, 1000)\n  }\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    document.getElementById(\"div1\").innerHTML =\n    \"Before the update, the favorite was \" + prevState.favoritecolor;\n  }\n  componentDidUpdate() {\n    document.getElementById(\"div2\").innerHTML =\n    \"The updated favorite is \" + this.state.favoritecolor;\n  }\n  render() {\n    return (\n      <div>\n        <h1>My Favorite Color is {this.state.favoritecolor}</h1>\n        <div id=\"div1\"></div>\n        <div id=\"div2\"></div>\n      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Header />);\nRun \nExample \u00bb\ncomponentDidUpdate\nThe\ncomponentDidUpdate\nmethod\nis called after the component is updated in the DOM.\nThe example below might seem complicated, but all it does is this:\nWhen the component is\nmounting\nit is rendered with the favorite \ncolor \"red\".\nWhen the component\nhas been mounted,\na timer changes the state, and \nthe color becomes \"yellow\".\nThis action triggers the\nupdate\nphase, and since this component has \na\ncomponentDidUpdate\nmethod, this method is \nexecuted and writes a message in the empty DIV element:\nExample:\nThe\ncomponentDidUpdate\nmethod is called \n  after the update has been rendered in the DOM:\nclass Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  componentDidMount() {\n    setTimeout(() => {\n      this.setState({favoritecolor: \"yellow\"})\n    }, 1000)\n  }\n  componentDidUpdate() {\n    document.getElementById(\"mydiv\").innerHTML =\n    \"The updated favorite is \" + this.state.favoritecolor;\n  }\n  render() {\n    return (\n      <div>\n      <h1>My Favorite Color is {this.state.favoritecolor}</h1>\n      <div id=\"mydiv\"></div>\n      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Header />);\nRun \nExample \u00bb\nUnmounting\nThe \nunmounting\nas React likes to call it.\nReact has only one built-in method that gets called when a component is unmounted:\ncomponentWillUnmount()\ncomponentWillUnmount\nThe\ncomponentWillUnmount\nmethod is \ncalled when the component is about to be removed from the DOM.\nExample:\nClick the button to delete the header:\nclass Container extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {show: true};\n  }\n  delHeader = () => {\n    this.setState({show: false});\n  }\n  render() {\n    let myheader;\n    if (this.state.show) {\n      myheader = <Child />;\n    };\n    return (\n      <div>\n      {myheader}\n      <button type=\"button\" onClick={this.delHeader}>Delete Header</button>\n      </div>\n    );\n  }\n}\n\nclass Child extends React.Component {\n  componentWillUnmount() {\n    alert(\"The component named Header is about to be unmounted.\");\n  }\n  render() {\n    return (\n      <h1>Hello World!</h1>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Container />);\nRun \nExample \u00bb\n\n\u2605\n+1",
      "order": 2,
      "code": null,
      "language": null,
      "explanation": null
    }
  ],
  "practice_exercises": [
    {
      "title": "Practice Exercise",
      "description": "Create an example that applies the concepts from this tutorial.",
      "difficulty": "medium",
      "starter_code": "# Add your code here",
      "solution": "# Example solution would go here"
    }
  ],
  "related_topics": [
    {
      "id": "a5f6cca4-bab2-495f-ba83-deb170abf300",
      "title": "C Best Practices",
      "relationship": "related_topic"
    },
    {
      "id": "79cdab67-2e28-4f65-a886-1e8a16c4dc2e",
      "title": "C Common Pitfalls and How to Avoid Them",
      "relationship": "suggested_reading"
    },
    {
      "id": "fa3242a6-b076-4ae1-be86-f2ad6407ef5b",
      "title": "C Fundamentals",
      "relationship": "prerequisite"
    }
  ],
  "quiz": [
    {
      "question": "What is Function components?",
      "options": [
        "now almost equivalent to Class components",
        "None of the above.",
        "so minor that you will probably never need to use a Class component in React",
        "None of the above."
      ],
      "correct_answer": 0,
      "explanation": "The correct definition of Function components is 'now almost equivalent to Class components'."
    },
    {
      "question": "What is The differences?",
      "options": [
        "None of the above.",
        "so minor that you will probably never need to use a Class component in React",
        "None of the above.",
        "now almost equivalent to Class components"
      ],
      "correct_answer": 1,
      "explanation": "The correct definition of The differences is 'so minor that you will probably never need to use a Class component in React'."
    }
  ],
  "summary": "This tutorial covers React Class Components concepts and techniques. You'll learn how to use React Class Components effectively, including key principles, common patterns, and practical examples. By the end of this tutorial, you'll have a solid understanding of React Class Components and how to apply it in your projects."
}