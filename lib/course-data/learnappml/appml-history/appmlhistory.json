{
  "id": "cd3e0fc9-cb59-4c30-903d-7f2f2366b67a",
  "title": "AppMLHistory",
  "slug": "appmlhistory",
  "metadata": {
    "description": "Learn about AppMLHistory with clear explanations and practical examples.",
    "keywords": [
      "applications",
      "appml",
      "application",
      "internet",
      "development",
      "must",
      "future",
      "files",
      "services",
      "developer"
    ],
    "difficulty": "intermediate",
    "prerequisites": [],
    "estimated_time": 5,
    "category": "LearnAppML",
    "subcategory": "AppML History"
  },
  "content_sections": [
    {
      "type": "introduction",
      "title": "Introduction",
      "content": "AppML\nHistory",
      "order": 1,
      "code": null,
      "language": null,
      "explanation": null
    },
    {
      "type": "concept",
      "title": "Details",
      "content": "In 1999 Refsnes Data developed the first version of AppML.\nAlready then,\u00a0 AppML was based on HTTP request communication \nbetween web client and the web server. Later this method became well known as \nAJAX.\nIn September 2000, a development project for a large Norwegian customer was \nstarted. The goal of the project was to convert a huge information system (about \n300 applications) from a Windows desktop application to a modern Internet \napplication, using only AppML.\nThe AppML-based system was launched in 2001, \nseveral months before schedule, as the world's first commercial AJAX \napplication. The project was a huge success, with development time reduced by \n75% compared to ordinary web development. Since then, new \napplications have been added, and the system now covers over 1000 running \napplications.\nIn February 2015,  re-launched AppML as a new product, open to the \npublic.\nAppML design goals:\nAppML applications must run over the Internet\nAppML applications must be platform independent\nAppML applications must use Internet standards only (HTML, CSS, \n    JavaScript)\nAppML applications must support a variety of application needs\nAppML applications must be self-describing\nAppML applications must be easy to develop, maintain and change\nAppML applications must be future proof\nThe paragraphs below describes Refsnes Data's original visions (1999) about future web applications.\nExecutables Will Die, JavaScript Will Live\nCompiled executables (compiled from languages like C or Java) cannot run on \ndifferent hardware.\nExecutables (EXE files, ActiveX and COM objects, DLL-files) are components \nthat prevent the development of applications that can \nrun over the internet.\nFuture application will not use, or rely on, executables or any other components installed on the \nclient's computer.\nOur suggestions:\nWrite your future applications using only HTML, CSS and JavaScript.\nMake sure your future applications run in any web browser.\nWeb Applications Will be Internet Services\nThe history is full of large, purpose built, applications. Many of these died \nvery quickly, because they could not survive requirements changes.\nApplications should be flexible, generalized, and gracefully adjust to \nchanges, without being crumbled or destroyed.\nApplications should be able to scale from supporting a few to millions of\nrequests per day.\nApplications should be able to spread from one server to\nmany, or to move between servers, without breaking the\napplication.\nApplications should be able to cooperate with other applications.\nApplications should not contain large masses of \ncode.\nApplications should be broken down into smaller \nservices, that are easy to create and easy to maintain.\nApplications should be a set of Internet services\nthat can return data to submitted Internet requests.\nApplications should request services via standard Internet protocols without maintaining a permanent connection to the server.\nOur suggestions:\nWrite your future applications using Internet based SOA \n(Service Oriented Architecture).\nMake your application services general and flexible, and ready to \nserve different types of requests.\nFuture Applications Will be Easy to Create and Edit\nClients and servers will exchange data in an easy understandable way.\nApplications will not be coded, if it can be avoided.\nApplications will be created and modified, by editing models, not by editing code.\nApplication descriptions will be readable by humans.\nApplication descriptions will be self describing.\nApplications will be written by users, not programmers.\nOur suggestions:\nUse human readable text\nfiles to describe services, and \nprovide services by executing these descriptions.\nUse text \nfiles (like JSON files) to describe applications.\nUse text \nfiles (like JSON files) to exchange data.\nUse HTML, CSS, and JavaScript to execute applications.\nThree Little Web Developers...\nOnce upon a time there were three little web developers developing a new web \nsite.\n1. The first web developer was using AppML.\n2. The second web developer was using his favorite server \nprogramming language.\n3. The third was using a \nprofessional enterprise web development framework.\nThe first web developer had a demo up \nand running in two days. After collaboration with the users, an exiting prototype was ready in a week. \nAnd after two \nweeks of testing, an intelligent, fast and easy to use, web site, was ready \nto publish.\nThe second web developer had his web site ready after 6 months. But the \nWWW had changed its requirements, and was not satisfied. The \nweb developer could \nnot make major changes to his project because it contained too much code. So he \nstarted the \ndevelopment of version 2.\nThe third web developer never managed to complete his work. The professional web development framework was very \ndifficult to use, very hard to understand, and almost impossible to test.\nTake a look at how the first developer did it\n.\n\n\u2605\n+1",
      "order": 2,
      "code": null,
      "language": null,
      "explanation": null
    }
  ],
  "practice_exercises": [
    {
      "title": "Create a Layout",
      "description": "Build a simple layout using the techniques from this tutorial.",
      "difficulty": "easy",
      "starter_code": "<!-- Add your code here -->",
      "solution": "<!-- Example solution would go here -->"
    }
  ],
  "related_topics": [
    {
      "id": "4d545091-5166-48dd-8cc3-db6a391df72c",
      "title": "Unknown Best Practices",
      "relationship": "related_topic"
    },
    {
      "id": "e74401eb-6397-4587-b6f6-bea0c5934ffd",
      "title": "Unknown Common Pitfalls and How to Avoid Them",
      "relationship": "suggested_reading"
    },
    {
      "id": "ce0ef1fa-4d4b-442c-accd-67709439929a",
      "title": "Unknown Fundamentals",
      "relationship": "prerequisite"
    }
  ],
  "quiz": [
    {
      "question": "What is Web Applications Will be Internet Services\nThe history?",
      "options": [
        "Not a Web Applications Will be Internet Services\nThe history.",
        "None of the above.",
        "full of large",
        "None of the above."
      ],
      "correct_answer": 2,
      "explanation": "The correct definition of Web Applications Will be Internet Services\nThe history is 'full of large'."
    },
    {
      "question": "Which best describes the main purpose of this javascript feature?",
      "options": [
        "To organize and structure code",
        "To improve code readability",
        "To enhance performance",
        "All of the above"
      ],
      "correct_answer": 3,
      "explanation": "This feature serves multiple purposes in software development."
    }
  ],
  "summary": "This tutorial covers AppMLHistory concepts and techniques. You'll learn how to use AppMLHistory effectively, including key principles, common patterns, and practical examples. By the end of this tutorial, you'll have a solid understanding of AppMLHistory and how to apply it in your projects."
}